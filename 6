updateResults() {
  // Map UI field names â†’ backend keys (except Measure)
  const fieldToJsonKey: Record<string, string | null> = {
    'Basket_Name': 'basket_name',
    'Factor_Description': 'factor_description',
    'Factor_name': 'factor_name',
    'Factor_group_name': 'factor_group_name',
    'Basket_Region': 'basket_region',
    'Measure': null   // handled separately
  };

  const mandatoryFields = ['Basket_Name', 'Factor_Description', 'Measure'];
  const missing = mandatoryFields.filter(f => {
    const field = this.fields.find(x => x.name === f);
    return !field || field.value.length === 0;
  });

  if (missing.length > 0) {
    this.snackBar.open(
      'Please select at least one value for all mandatory fields',
      'Close',
      { duration: 3000, verticalPosition: 'top' }
    );
    return;
  }

  // Build filters object for API
  const filters: Record<string, any> = {};
  this.fields.forEach(f => {
    const jsonKey = fieldToJsonKey[f.name];
    if (jsonKey && f.value.length > 0) {
      filters[jsonKey] = f.value;  // arrays for multiselect
    }
  });

  // Handle Measure separately
  const measureField = this.fields.find(f => f.name.toLowerCase() === 'measure');
  const selectedMeasures = measureField?.value ?? [];

  if (selectedMeasures.includes('Raw')) {
    filters['is_raw_available'] = true;
  }
  if (selectedMeasures.includes('Std')) {
    filters['is_std_available'] = true;
  }

  console.log('Filters sent to API:', filters);

  // Call API through service
  this.filterService.getResults(filters).subscribe({
    next: (res: any) => {
      this.results = res;
      this.selectedRows.clear();
      this.selectAllChecked = false;

      if (this.results.length === 0) {
        this.snackBar.open('No matching entries found', 'Close', {
          duration: 3000,
          verticalPosition: 'top'
        });
      }

      console.log('Filtered results from API:', this.results);
    },
    error: (err) => {
      console.error('Error fetching results', err);
      this.snackBar.open('Error fetching results', 'Close', { duration: 3000 });
    }
  });
}
// filter.service.ts
getResults(filters: Record<string, any>): Observable<any> {
  let params = new HttpParams();

  Object.keys(filters).forEach(key => {
    const value = filters[key];
    if (Array.isArray(value)) {
      value.forEach(v => {
        params = params.append(key, v);
      });
    } else {
      params = params.set(key, value);
    }
  });

  console.log('Final query params:', params.toString());

  return this.http.get(`${this.baseUrl}/results`, { params });
}
