getResults(filters: any) {
  console.log('Filters sent to API:', filters);  // log request
  return this.proxy.post('/getResults', filters)  // use your existing proxy method
    .pipe(
      tap(res => console.log('API response for getResults:', res))  // log response
    );
}
updateResults() {
  // Ensure mandatory fields are selected
  const mandatoryFields = ['Basket_Name', 'Factor_Description', 'Measure'];
  const missing = mandatoryFields.filter(f => {
    const field = this.fields.find(x => x.name === f);
    return !field || field.value.length === 0;
  });

  if (missing.length > 0) {
    this.snackBar.open(
      'Please select at least one value for all mandatory fields',
      'Close',
      { duration: 3000, verticalPosition: 'top' }
    );
    return;
  }

  // Build filters object to send to backend
  const filters: Record<string, string[]> = {};
  this.fields.forEach(f => {
    if (f.value.length > 0) {
      filters[f.name] = f.value;
    }
  });

  // Call service
  this.proxyService.getResults(filters).subscribe({
    next: (res: any) => {
      console.log('API returned:', res);

      // Map API response to table rows
      this.results = res.uniquValues.map((val: string) => ({
        basket_name: val,           // adjust according to your API keys
        factor_description: '',     // fill if API provides
        measure: '',                // fill if API provides
        unique: res.matchcount,
        constant: res.universecount,
        object_id: val
      }));

      this.selectedRows.clear();
      this.selectAllChecked = false;

      if (this.results.length === 0) {
        this.snackBar.open('No matching entries found', 'Close', {
          duration: 3000,
          verticalPosition: 'top'
        });
      }
    },
    error: (err) => {
      console.error('Error fetching results:', err);
      this.snackBar.open('Failed to fetch results', 'Close', {
        duration: 3000,
        verticalPosition: 'top'
      });
    }
  });
}
private proxyService: ProxyService
